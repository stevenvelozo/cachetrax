{"version":3,"sources":["cachetrax.compatible.min.js","node_modules/browser-pack/_prelude.js","source/CacheTrax-Browser-Shim.js","source/CacheTrax.js","source/LinkedList-Node.js","source/LinkedList.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","prototype","arg","_toPrimitive","_typeof","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","Number","obj","iterator","constructor","f","exports","module","define","amd","window","global","self","this","CacheTrax","r","e","n","t","o","c","require","u","a","Error","code","p","libNPMModuleWrapper","hasOwnProperty","libLinkedList","CashMoney","_HashMap","_List","maxLength","maxAge","value","pData","pHash","Datum","tmpNode","push","Hash","pop","Metadata","Created","Date","remove","put","fComplete","pRemovedRecords","tmpRemovedRecords","tmpNow","tmpKeys","keys","expire","fPruneFunction","_this","pruneBasedOnExpiration","fExpirationPruneComplete","pruneBasedOnLength","LinkedListNode","LeftNode","RightNode","__ISNODE","libLinkedListNode","LinkedList","totalNodes","head","tail","pDatum","tmpHash","concat","initializeNode","append","pNode","fAction","_this2","fIterator","pError","pNodeIndex"],"mappings":"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","file":"cachetrax.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.CacheTrax = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./CacheTrax.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('CacheTrax'))\n{\n\twindow.CacheTrax = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./CacheTrax.js\":2}],2:[function(require,module,exports){\n/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney\n{\n\tconstructor()\n\t{\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;\n},{\"./LinkedList.js\":4}],3:[function(require,module,exports){\n/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;\n},{}],4:[function(require,module,exports){\n\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;\n},{\"./LinkedList-Node.js\":3}]},{},[1])(1)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","var libNPMModuleWrapper = require('./CacheTrax.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('CacheTrax'))\n{\n\twindow.CacheTrax = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney\n{\n\tconstructor()\n\t{\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;","/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;","\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;"]}
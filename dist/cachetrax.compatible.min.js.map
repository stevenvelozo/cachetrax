{"version":3,"sources":["cachetrax.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/CacheTrax.js","source/LinkedList-Node.js","source/LinkedList.js"],"names":["_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","writable","configurable","defineProperty","_setPrototypeOf","o","p","setPrototypeOf","bind","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","_getPrototypeOf","NewTarget","this","Reflect","construct","arguments","apply","_possibleConstructorReturn","self","call","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","Number","iterator","f","exports","module","define","amd","window","global","Cachetrax","r","n","t","c","require","u","a","Error","code","FableCoreServiceProviderBase","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Math","floor","random","Hash","pFable","FableServiceProviderBase","isFable","getUUID","log","servicesMap","serviceMap","services","CoreServiceProviderBase","libFableServiceProviderBase","libLinkedList","CashMoney","_libFableServiceProvi","_super","pManifest","_this","_HashMap","_RecordMap","_List","maxLength","maxAge","get","pData","pHash","hasOwnProperty","Datum","tmpNode","push","pop","Metadata","Created","Date","remove","put","fComplete","pRemovedRecords","tmpRemovedRecords","tmpNow","tmpKeys","keys","expire","fPruneFunction","_this2","pruneBasedOnExpiration","fExpirationPruneComplete","pruneBasedOnLength","LinkedListNode","LeftNode","RightNode","__ISNODE","libLinkedListNode","LinkedList","totalNodes","head","tail","pDatum","tmpHash","initializeNode","append","pNode","fAction","_this3","fIterator","pError","pNodeIndex"],"mappings":"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","file":"cachetrax.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Cachetrax = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.serviceMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":1}],3:[function(require,module,exports){\n/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'ObjectCache';\n\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._RecordMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\tget RecordMap()\n\t{\n\t\treturn this._RecordMap;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\tthis._RecordMap[pHash] = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\t\tthis._RecordMap[pHash] = pData;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._RecordMap[pHash];\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t{\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\t\t\t}\n\t\t}\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;\n},{\"./LinkedList.js\":5,\"fable-serviceproviderbase\":2}],4:[function(require,module,exports){\n/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;\n},{}],5:[function(require,module,exports){\n\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;\n},{\"./LinkedList-Node.js\":4}]},{},[3])(3)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.serviceMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pManifest, pServiceHash)\n\t{\n\t\tif (pFable === undefined)\n\t\t{\n\t\t\tsuper({});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuper(pFable, pManifest, pServiceHash);\n\t\t}\n\n        this.serviceType = 'ObjectCache';\n\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._RecordMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\tget RecordMap()\n\t{\n\t\treturn this._RecordMap;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\tthis._RecordMap[pHash] = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\t\tthis._RecordMap[pHash] = pData;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._RecordMap[pHash];\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._RecordMap[tmpNode.Hash];\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t{\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\t\t\t}\n\t\t}\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t{\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t\t}\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t{\n\t\t\treturn fComplete(tmpRemovedRecords);\n\t\t}\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;","/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;","\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;"]}
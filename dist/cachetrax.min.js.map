{"version":3,"sources":["cachetrax.min.js","node_modules/browser-pack/_prelude.js","source/CacheTrax-Browser-Shim.js","source/CacheTrax.js","source/LinkedList-Node.js","source/LinkedList.js"],"names":["f","exports","module","define","amd","window","global","self","this","CacheTrax","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","libNPMModuleWrapper","hasOwnProperty","libLinkedList","constructor","_HashMap","_List","maxLength","maxAge","put","pData","pHash","Datum","tmpNode","push","Hash","pop","Metadata","Created","Date","touch","remove","expire","pruneBasedOnExpiration","fComplete","pRemovedRecords","tmpRemovedRecords","tmpNow","tmpKeys","Object","keys","pruneBasedOnLength","pruneCustom","fPruneFunction","prune","fExpirationPruneComplete","read","getNode","LeftNode","RightNode","__ISNODE","libLinkedListNode","totalNodes","head","tail","initializeNode","pDatum","tmpHash","concat","append","prepend","pNode","each","fAction","fIterator","pError","seek","pNodeIndex"],"mappings":"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","file":"cachetrax.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.CacheTrax = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nvar libNPMModuleWrapper = require('./CacheTrax.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('CacheTrax'))\n{\n\twindow.CacheTrax = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./CacheTrax.js\":2}],2:[function(require,module,exports){\n/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney\n{\n\tconstructor()\n\t{\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;\n},{\"./LinkedList.js\":4}],3:[function(require,module,exports){\n/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;\n},{}],4:[function(require,module,exports){\n\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;\n},{\"./LinkedList-Node.js\":3}]},{},[1])(1)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","var libNPMModuleWrapper = require('./CacheTrax.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('CacheTrax'))\n{\n\twindow.CacheTrax = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","/**\n* Cache data structure with:\n*  - enumerable items\n*  - unique hash item access (if none is passed in, one is generated)\n*  - size (length) expiration\n*  - controllable expiration (e.g. keep in cache longer if older/less likely to change)\n*  - time-based expiration\n*  - custom expiration based on passed-in function\n*\n* Also:\n*  - built to work well with browserify\n*  - no dependencies at all\n*  - pet friendly\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nconst libLinkedList = require(`./LinkedList.js`);\n\nclass CashMoney\n{\n\tconstructor()\n\t{\n\t\t// The map of node objects by hash because Reasons.\n\t\tthis._HashMap = {};\n\n\t\tthis._List = new libLinkedList();\n\n\t\t// If the list gets over maxLength, we will automatically remove nodes on insertion.\n\t\tthis.maxLength = 0;\n\n\t\t// If cache entries get over this age, they are removed with prune\n\t\tthis.maxAge = 0;\n\t}\n\n\t// Add (or update) a node in the cache\n\tput(pData, pHash)\n\t{\n\t\t// If the hash of the record exists\n\t\tif (this._HashMap.hasOwnProperty(pHash))\n\t\t{\n\t\t\t// Just update the hashed records datum\n\t\t\tthis._HashMap[pHash].Datum = pData;\n\t\t\treturn this._HashMap[pHash].Datum;\n\t\t}\n\n\t\tlet tmpNode = this._List.push(pData, pHash);\n\t\tthis._HashMap[tmpNode.Hash] = tmpNode;\n\n\t\t// Automatically prune if over length, but only prune this nodes worth.\n\t\tif (this.maxLength > 0   &&   this._List.length > this.maxLength)\n\t\t{\n\t\t\t// Pop it off the head of the list\n\t\t\ttmpNode = this._List.pop();\n\t\t\t// Also remove it from the hashmap\n\t\t\tdelete this._HashMap[tmpNode.Hash];\n\t\t}\n\n\t\t// Now some expiration properties on the node metadata... namely the birthdate in ms of the node\n\t\ttmpNode.Metadata.Created = +new Date();\n\n\t\treturn tmpNode.Datum;\n\t}\n\n\t// Reinvigorate a node based on hash, updating the timestamp and moving it to the head of the list (also removes custom metadata)\n\ttouch(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\t// Get the old node out of the list\n\t\tlet tmpNode = this._List.remove(this._HashMap[pHash]);\n\t\t// Remove it from the hash map\n\t\tdelete this._HashMap[pHash];\n\n\t\t// Now put it back, fresh.\n\t\treturn this.put(tmpNode.Datum, tmpNode.Hash);\n\t}\n\n\t// Expire a cached record based on hash\n\texpire(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\tlet tmpNode = this._HashMap[pHash];\n\n\t\t// Remove it from the list of cached records\n\t\ttmpNode = this._List.remove(tmpNode);\n\t\t// Also remove it from the hashmap\n\t\tdelete this._HashMap[tmpNode.Hash];\n\n\t\t// Return it in case the consumer wants to do anything with it\n\t\treturn tmpNode;\n\t}\n\n\t// Prune records from the cached set based on maxAge\n\tpruneBasedOnExpiration(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tif (this.maxAge < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now enumerate each record and remove any that are expired\n\t\tlet tmpNow = +new Date();\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\t// Expire the node if it is older than max age milliseconds\n\t\t\tif (tmpNow - this._HashMap[tmpKeys[i]].Metadata.Created >= this.maxAge)\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on maxLength\n\tpruneBasedOnLength(fComplete, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\t// Pop records off until we have reached maxLength unless it's 0\n\t\tif (this.maxLength > 0)\n\t\t\twhile (this._List.length > this.maxLength)\n\t\t\t\ttmpRemovedRecords.push(this._List.pop());\n\n\t\treturn fComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune records from the cached set based on passed in pPruneFunction(pDatum, pHash, pNode) -- returning true expires it\n\tpruneCustom(fComplete, fPruneFunction, pRemovedRecords)\n\t{\n\t\tlet tmpRemovedRecords = (typeof(pRemovedRecords) === 'undefined') ? [] : pRemovedRecords;\n\n\t\tlet tmpKeys = Object.keys(this._HashMap);\n\t\tfor (let i = 0; i < tmpKeys.length; i++)\n\t\t{\n\t\t\tlet tmpNode = this._HashMap[tmpKeys[i]];\n\t\t\t// Expire the node if the passed in function returns true\n\t\t\tif (fPruneFunction(tmpNode.Datum, tmpNode.Hash, tmpNode))\n\t\t\t\ttmpRemovedRecords.push(this.expire(tmpKeys[i]));\n\t\t}\n\t\tfComplete(tmpRemovedRecords);\n\t}\n\n\t// Prune the list down to the asserted rules (max age then max length if still too long)\n\tprune(fComplete)\n\t{\n\t\tlet tmpRemovedRecords = [];\n\n\t\t// If there are no cached records, we are done.\n\t\tif (this._List.length < 1)\n\t\t\treturn fComplete(tmpRemovedRecords);\n\n\t\t// Now prune based on expiration time\n\t\tthis.pruneBasedOnExpiration((fExpirationPruneComplete)=>\n\t\t\t{\n\t\t\t\t// Now prune based on length, then return the removed records in the callback.\n\t\t\t\tthis.pruneBasedOnLength(fComplete, tmpRemovedRecords);\n\t\t\t}, tmpRemovedRecords);\n\t}\n\n\t// Read a datum by hash from the cache\n\tread(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash].Datum;\n\t}\n\n\t// Get a low level node (including metadata statistics) by hash from the cache\n\tgetNode(pHash)\n\t{\n\t\tif (!this._HashMap.hasOwnProperty(pHash))\n\t\t\treturn false;\n\n\t\treturn this._HashMap[pHash];\n\t}\n}\n\nmodule.exports = CashMoney;","/**\n* Double Linked List Node\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module CashMoney\n*/\n\n/**\n* Linked List Node Prototype\n*\n* @class LinkedListNode\n* @constructor\n*/\n\nclass LinkedListNode\n{\n\tconstructor()\n\t{\n\t\tthis.Hash = false;\n\t\tthis.Datum = false;\n\n\t\t// This is where expiration and other elements are stored;\n\t\tthis.Metadata = {};\n\n\t\tthis.LeftNode = false;\n\t\tthis.RightNode = false;\n\n\t\t// To allow safe specialty operations on nodes\n\t\tthis.__ISNODE = true;\n\t}\n}\n\nmodule.exports = LinkedListNode;","\"use strict\"\n/**\n* Simple double linked list to hold the cache entries in, in order.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module FeeFiFo\n*/\n\nconst libLinkedListNode = require('./LinkedList-Node.js');\n\n/**\n* Quality Cache Goodness\n*\n* @class CashMoney\n* @constructor\n*/\n\nclass LinkedList\n{\n\tconstructor()\n\t{\n\t\t// Total number of nodes ever processed by this ADT\n\t\tthis.totalNodes = 0;\n\n\t\t// The length of the set of nodes currently in the list\n\t\tthis.length = 0;\n\n\t\tthis.head = false;\n\t\tthis.tail = false;\n\t}\n\n\t// Create a node object.\n\tinitializeNode(pDatum, pHash)\n\t{\n\t\t// Don't allow undefined to be added to the list because of reasons\n\t\tif (typeof(pDatum) === 'undefined')\n\t\t\treturn false;\n\n\t\tthis.totalNodes++;\n\n\t\t// Get (or create) a unique hash\n\t\tlet tmpHash = (typeof(pHash) != 'undefined') ? pHash : `NODE[${this.totalNodes}]`;\n\n\t\tlet tmpNode = new libLinkedListNode();\n\n\t\ttmpNode.Hash = tmpHash;\n\t\ttmpNode.Datum = pDatum;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Add a node to the end (right of tail) of the list.\n\tappend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.tail.RightNode = tmpNode;\n\t\ttmpNode.LeftNode = this.tail;\n\t\tthis.tail = tmpNode;\n\n\t\treturn tmpNode;\n\t}\n\n\t// Append to tail of list (FIFO)\n\tpush(pDatum, pHash)\n\t{\n\t\treturn this.append(pDatum, pHash);\n\t}\n\n\t// Add a node to the beginning (left of head) of the list.\n\tprepend(pDatum, pHash)\n\t{\n\t\t// TODO: Should we check if pDatum is actually a node and do the \"right\" thing?\n\t\tlet tmpNode = this.initializeNode(pDatum, pHash);\n\t\tif (!tmpNode)\n\t\t\treturn false;\n\n\t\t// The list just got longer!\n\t\tthis.length++;\n\n\t\t// If the list was empty, create a new list from it (it isn't possible to have a tail with no head)\n\t\tif (this.length == 1)\n\t\t{\n\t\t\tthis.head = tmpNode;\n\t\t\tthis.tail = tmpNode;\n\t\t\treturn tmpNode;\n\t\t}\n\n\t\tthis.head.LeftNode = tmpNode;\n\t\ttmpNode.RightNode = this.head;\n\t\tthis.head = tmpNode;\n\t\treturn tmpNode;\n\t}\n\n\t// Remove a node from the list\n\tremove(pNode)\n\t{\n\t\tif (typeof(pNode) === 'undefined')\n\t\t\treturn false;\n\n\t\tif (!pNode.__ISNODE)\n\t\t\treturn false;\n\n\t\tthis.length--;\n\n\t\t// Last element in list.  Empty it out.\n\t\tif (this.length < 1)\n\t\t{\n\t\t\tthis.head = false;\n\t\t\tthis.tail = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's somewhere in the middle, surgically remove it.\n\t\tif (pNode.LeftNode && pNode.RightNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = pNode.RightNode;\n\t\t\tpNode.RightNode.LeftNode = pNode.LeftNode;\n\n\t\t\tpNode.RightNode = false;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It's the tail\n\t\tif (pNode.LeftNode)\n\t\t{\n\t\t\tpNode.LeftNode.RightNode = false;\n\t\t\tthis.tail = pNode.LeftNode;\n\t\t\tpNode.LeftNode = false;\n\t\t\treturn pNode;\n\t\t}\n\n\t\t// It must be the head\n\t\tpNode.RightNode.LeftNode = false;\n\t\tthis.head = pNode.RightNode;\n\t\tpNode.RightNode = false;\n\t\treturn pNode;\n\t}\n\n\t// Remove the head of the list (FIFO)\n\tpop()\n\t{\n\t\treturn this.remove(this.head);\n\t}\n\n\t// Enumerate over each node IN ORDER, running the function fAction(pDatum, pHash, fCallback) then calling the function fComplete callback when done\n\teach(fAction, fComplete)\n\t{\n\t\tif (this.length < 1)\n\t\t\treturn fComplete();\n\n\t\tlet tmpNode = false;\n\n\t\tlet fIterator = (pError)=>\n\t\t{\n\t\t\t// If the user passed in a callback with an error, call their callback with the error\n\t\t\tif (pError)\n\t\t\t\treturn fComplete(pError);\n\n\t\t\t// If there is no node, this must be the initial run.\n\t\t\tif (!tmpNode)\n\t\t\t\ttmpNode = this.head;\n\t\t\t// Check if we are at the tail of the list\n\t\t\telse if (!tmpNode.RightNode)\n\t\t\t\treturn fComplete();\n\t\t\t// Proceed to the next node\n\t\t\telse\n\t\t\t\ttmpNode = tmpNode.RightNode;\n\n\t\t\t// Call the actual action\n\t\t\t// I hate this pattern because long tails eventually cause stack overflows.\n\t\t\tfAction(tmpNode.Datum, tmpNode.Hash, fIterator);\n\t\t};\n\n\t\t// Now kick off the iterator\n\t\treturn fIterator();\n\t}\n\n\t// Seek a specific node, 0 is the index of the first node.\n\tseek(pNodeIndex)\n\t{\n\t\tif (!pNodeIndex)\n\t\t\treturn false;\n\t\tif (this.length < 1)\n\t\t\treturn false;\n\t\tif (pNodeIndex >= this.length)\n\t\t\treturn false;\n\n\t\tlet tmpNode = this.head;\n\t\tfor (let i = 0; i < pNodeIndex; i++)\n\t\t{\n\t\t\ttmpNode = tmpNode.RightNode;\n\t\t}\n\n\t\treturn tmpNode;\n\t}\n}\n\nmodule.exports = LinkedList;"]}